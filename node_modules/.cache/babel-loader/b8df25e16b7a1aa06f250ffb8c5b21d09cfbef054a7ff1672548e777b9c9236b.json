{"ast":null,"code":"import { Cell } from \"./Cell\";\nimport { Colors } from \"./Colors\";\nimport { Pawn } from \"./figures/Pawn\";\nimport { Rook } from \"./figures/Rook\";\nimport { Knight } from \"./figures/Knight\";\nimport { Bishop } from \"./figures/Bishop\";\nimport { Queen } from \"./figures/Queen\";\nimport { King } from \"./figures/King\";\nexport class Board {\n  constructor() {\n    this.cells = [];\n  }\n  initCells() {\n    for (let j = 0; j < 8; j++) {\n      let row = [];\n      for (let i = 0; i < 8; i++) {\n        if ((i + j) % 2 === 0) {\n          row.push(new Cell(this, i, j, Colors.WHITE, null)); // Белые ячейки\n        } else {\n          row.push(new Cell(this, i, j, Colors.BLACK, null)); // Чёрные ячейки\n        }\n      }\n\n      this.cells.push(row);\n    }\n  }\n  getCell(x, y) {\n    return this.cells[y][x] || null;\n  }\n  setFigures() {\n    this.cells.forEach((row, index) => {\n      if (index === 1) {\n        row.forEach(cell => new Pawn(Colors.BLACK, cell));\n      }\n      if (index === 6) {\n        row.forEach(cell => new Pawn(Colors.WHITE, cell));\n      }\n      if (index === 0) {\n        row.forEach((cell, index) => {\n          if (index === 0 || index === 7) {\n            new Rook(Colors.BLACK, cell);\n          }\n          if (index === 1 || index === 6) {\n            new Knight(Colors.BLACK, cell);\n          }\n          if (index === 2 || index === 5) {\n            new Bishop(Colors.BLACK, cell);\n          }\n          if (index === 3) {\n            new Queen(Colors.BLACK, cell);\n          }\n          if (index === 4) {\n            new King(Colors.BLACK, cell);\n          }\n        });\n      }\n      if (index === 7) {\n        row.forEach((cell, index) => {\n          if (index === 0 || index === 7) {\n            new Rook(Colors.WHITE, cell);\n          }\n          if (index === 1 || index === 6) {\n            new Knight(Colors.WHITE, cell);\n          }\n          if (index === 2 || index === 5) {\n            new Bishop(Colors.WHITE, cell);\n          }\n          if (index === 3) {\n            new Queen(Colors.WHITE, cell);\n          }\n          if (index === 4) {\n            new King(Colors.WHITE, cell);\n          }\n        });\n      }\n    });\n  }\n  availableCellsForMove(cell) {\n    this.cells.forEach(row => {\n      row.forEach(cage => {\n        var _cell$figure;\n        return cell !== null && cell !== void 0 && (_cell$figure = cell.figure) !== null && _cell$figure !== void 0 && _cell$figure.canMove(cage) ? cage.available = !cage.available : cage.available = false;\n      });\n    });\n  }\n  updatedBoard() {\n    let newBoard = new Board();\n    newBoard.cells = this.cells;\n    return newBoard;\n  }\n}","map":{"version":3,"names":["Cell","Colors","Pawn","Rook","Knight","Bishop","Queen","King","Board","constructor","cells","initCells","j","row","i","push","WHITE","BLACK","getCell","x","y","setFigures","forEach","index","cell","availableCellsForMove","cage","_cell$figure","figure","canMove","available","updatedBoard","newBoard"],"sources":["/home/arthas/chess/src/model/Board.ts"],"sourcesContent":["import { Cell } from \"./Cell\"\nimport { Colors } from \"./Colors\"\nimport { Pawn } from \"./figures/Pawn\";\nimport { Rook } from \"./figures/Rook\";\nimport { Knight } from \"./figures/Knight\";\nimport { Bishop } from \"./figures/Bishop\";\nimport { Queen } from \"./figures/Queen\";\nimport { King } from \"./figures/King\";\n\nexport class Board {\n    \n    cells: Cell[][] = []\n    \n    initCells() {\n        for (let j: number = 0; j < 8; j++) {\n            let row: Cell[] = [];\n\n            for (let i: number = 0; i < 8; i++) {\n                if ((i + j) % 2 === 0) {\n                    row.push(new Cell(this, i, j, Colors.WHITE, null)) // Белые ячейки\n                } else {\n                    row.push(new Cell(this, i, j, Colors.BLACK, null)) // Чёрные ячейки\n                }\n            }\n            this.cells.push(row)\n        }\n    }\n    getCell(x: number, y: number): Cell | null {\n        return this.cells[y][x] || null\n    }\n    setFigures() {\n        this.cells.forEach((row, index) => {\n            if (index === 1) {\n                row.forEach(cell => new Pawn(Colors.BLACK, cell))\n            }\n            if (index === 6) {\n                row.forEach(cell => new Pawn(Colors.WHITE, cell))\n            }\n            if (index === 0) {\n                row.forEach((cell, index) => {\n                    if ((index === 0) || (index === 7)) {\n                        new Rook(Colors.BLACK, cell)\n                    }\n                    if ((index === 1) || (index === 6)) {\n                        new Knight(Colors.BLACK, cell)\n                    }\n                    if ((index === 2) || (index === 5)) {\n                        new Bishop(Colors.BLACK, cell)\n                    }\n                    if (index === 3) {\n                        new Queen(Colors.BLACK, cell)\n                    }\n                    if (index === 4) {\n                        new King(Colors.BLACK, cell)\n                    }\n                })\n            }\n            if (index === 7) {\n                row.forEach((cell, index) => {\n                    if ((index === 0) || (index === 7)) {\n                        new Rook(Colors.WHITE, cell)\n                    }\n                    if ((index === 1) || (index === 6)) {\n                        new Knight(Colors.WHITE, cell)\n                    }\n                    if ((index === 2) || (index === 5)) {\n                        new Bishop(Colors.WHITE, cell)\n                    }\n                    if (index === 3) {\n                        new Queen(Colors.WHITE, cell)\n                    }\n                    if (index === 4) {\n                        new King(Colors.WHITE, cell)\n                    }\n                })\n            }\n        })\n    }\n    availableCellsForMove(cell: Cell | null) {\n        this.cells.forEach(row => {\n            row.forEach(cage => cell?.figure?.canMove(cage) ? cage.available = !cage.available : cage.available = false)\n        })\n    }\n    updatedBoard() {\n        let newBoard = new Board();\n        newBoard.cells = this.cells;\n        return newBoard\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}